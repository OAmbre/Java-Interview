## 京东（成都）一面面经
- [https://www.nowcoder.com/discuss/423874](https://www.nowcoder.com/discuss/423874)

### redis平时的使用（消息队列如何实现的）
> Redis能做消息队列得益于他list对象blpop/brpop接口以及Pub/Sub(发布/订阅)的某些接口。他们都是阻塞版的，所以Redis实现消息队列有两种方式：

- 通过数据结构list来实现
- 通过pub/sub来实现

#### 通过数据结构list来实现
消息接收：
```
redis> brpop tasklist 0
“im task 01”
```
这个例子使用blpop命令会阻塞方式地从tasklist列表中取头一个数据，最后一个参数就是等待超时的时间。如果设置为0则表示无限等待。
消息发送：
```
redis> lpush tasklist ‘im task 01’
redis> lpush tasklist ‘im task 02’
```

优点：
- 能够实现持久化：采用 Master－Slave 数据复制模式。队列操作都是写操作，Master任务繁重，能让Slave分担的持久化工作，就不要Master做。RDB和AOF两种方法都用上，多重保险。
- 支持集群
- 接口使用简单

不足：
- Redis上消息只会被一个消费者消费，不会有多个订阅者消费同一个消息，简单一对一
- 生产者或者消费者崩溃后的处理机制，需要自己实现
- 生产者写入太快，消费者消费太慢，导致Redis的内存问题，处理机制需要自己实现

#### 通过pub/sub来实现
> 订阅，取消订阅和发布实现了发布/订阅消息范式，发布者不是计划发送消息给特定的订阅者。而是发布的消息分到不同的频道，不需要知道什么样的订阅者订阅。订阅者对一个或多个频道感兴趣，只需接收感兴趣的消息，不需要知道什么样的发布者发布的。
  这是一种基于非持久化的消息机制，消息发布者和订阅者必须同时在线，否则一旦消息订阅者由于各种异常情况而被迫断开连接，在其重新连接后，其离线期间的消息是无法被重新通知的（即发即弃）。

优点：
- 一个生产者能够对应多个消费者
- 支持集群
- 接口使用简单

不足：
- 首先这些消息并没有持久化机制，属于即发即弃模式。
- 由于本来就是即发即弃的消息模式，所以Redis也不需要专门制定消息的备份和恢复机制。
- Redis也没有为发布者和订阅者准备保证消息性能的任何方案，例如在大量消息同时到达Redis服务是，如果消息订阅者来不及完成消费，就可能导致消息堆积。而ActiveMQ中有专门针对这种情况的慢消息机制。

### spring boot启动的过程（run方法和bean的生命周期）


